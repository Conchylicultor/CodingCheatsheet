================================================================================
========= Base code
===============================================
====== Hello world
=== cpp
#import <iostream>
#import <cstdio>
#import <vector>

int foo(const std::vector& v)
{
    for(size_t i = 0 ; i < v.size() ; ++i)
    {}
    return 0;
}

int main(int argc, char** argv)
{
    std::cout << "Hello " << 4 << " humans"<< std::endl;
    printf("Hello %d %s\n", 4, "humans");
    return 0; // EXIT_SUCCESS (defined in stdlib)
}
=== java
import java.lang.Math;

public class HelloWorld
{
    public static void main (String[] args)  // WARNING: public and static keywords
    {
        System.out.println("Hello");
    }
}

// WARNING: == compare refs, not values (ex: String). No operators overloading

=== python
if __name__ == '__main__':
    print('Hello {} humans'.format(4))
===============================================
====== Loops
=== cpp
for(size_t i = 0 ; i < myList.size() ; ++i);  // Warning: size_t unsigned so overflow when reverse iterate (; i >= 0 ; --i)
for(const std::string& s : myList);
for(auto x : v); // Work with copy
for(auto& x : v);
for(auto const& : v); // Work with const reference

continue;
break;
=== java
for (String s : myList) {
}

continue;
break;
=== python
# For loops have an else clause
for x in my_list:
    if x == target:
        break
else:  # No break or empty list
    print('target not found')

for i in range(100):  # xrange for 2.6
    pass

continue
break
===============================================
====== Switch
=== cpp
switch (value)  // Only works with integer (or enums)
{
    case 1:
        // ...
        break;
    default:
        // ...
}
=== java
switch (month)  // Also works with String
{
    case "January":
        // ...
        break;
    default:
        // ...
}
=== python
===============================================
====== Exceptions
=== cpp
try
{
    throw Exception();  // In C++, exceptions can be any objects (int,...)
    // common to inherit from std::exception and override const char* what()
}
catch (Exception& e)  // Can only catch one exception
{
    cout << e.what() << endl;
}
catch (...)
{
    // Default exception
} // No finally in c++
=== java
try {
    // If return here, the value is stored, then finally is called, then the stored value is returned
} catch(ArrayIndexOutOfBoundsException e) {
    // ...
} catch(IOException|SQLException e) { // Catch 2 exceptions
    e.printStackTrace();
} catch(Exception e) {
    // ...
} finally {
    // ...
}

// If not surrounded by try {} catch {}, the function must explicitly declare: throw

void f() throw E // E inherit of Exception extends Throwable
{
}

// Throwable is the interface (Should not be catch (except eventually in main() ))
// Exception is the class
=== python
try:
    raise AttributeError
except IOError as e:  # (KeyboardInterrupt, EOFError) as e:  # For multiple exceptions at once
    pass
except: # OR: except Exception as e:
    pass
else: # If no exceptions
    pass
finally: # In any case (even if return statement)
    pass

# Good practice to hide/wrap exception handling inside context manager
===============================================
====== Templates/generics
=== cpp
=== java
=== python
================================================================================
========= Primitives, operators
===============================================
====== Primitives
=== cpp
bool b = true;
std::string s = "Hello";

std::variant<T1, T2, T3> v{}; // Default is T1
auto v2 = std::get<T2>(v); // Throw exception
auto v2 = std::get_if<T2>(v); // Return nullptr
v.index() // 0 if T1, 1 if T2,...

union MyUnion {T1 t1; T2 t2;};  // (one type among multiples): Bad (prefer std::variant)

std::optional<std::string> var; // Can be a string or a not value (like None in python) C++17
var.value_or("default"); // .has_value() ; .value()
=== java
boolean b = true;
String s = "Hello"
=== python
b = True
s = 'Hello'

z = complex(1, 4)  # = 1 + 4j

# Types: bool, str, int, float, list, tuple, dict, set,...
===============================================
====== Enum
=== cpp
enum e {a, b, c=a+3}; // start at 0, then +1
enum class e {a, b, c}; // strongly typed in C++11
=== java
public enum Day {MONDAY, TUESDAY} // No custom values;
=== python
class Day(enum.Enum):  # Since 3.4
    MON = enum.auto()
    TUE = enum.auto()  # auto() since 3.6, before, explicit was better than implicit...

Day = enum.Enum('Day', 'MON, TUE, WED')  # as collections.namedtuple

Mode = enum.Flag('Mode', 'r, w')  # Since 3.6, Flags compatible with &, |, ^, ~
====== Type checking and deduction
=== cpp
decltype(a->x) y;   // type of y is double (declared type)
decltype((a->x)) z = y; // type of z is const double& (lvalue expression)
using Type_t = decltype( fct() );
// When return type depends on template parameters
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u)
{
}

// Type checking (statically at compile time)
std::is_same<T1, T2>::value // Or is_same_v<T> since C++14
std::remove_reference<int>::type // Or remove_reference_t<T>
=== java
=== python
type(o) is str
isinstance(o, basestring)  # Also take into account child classes
===============================================
====== Casting
=== cpp
// Cast
static_cast<>(x) // Standard conversion (ex: double to float)
reinterpret_cast<>(x) // Bits don't change (ex: char* to int*)
const_cast<>(c)
dynamic_cast<>(); // For inheritance

// To overload cast
explicit operator bool () const; // explicit prevent bool a = obj
operator int* () const; // Note the absence of return value in the signature
operator MyType () const; // Custom cast
=== java
float newVar = (float)oldVar; // C like syntax
=== python
str(x)
int(x) # associated __int__(self) to overload
float(x) # __float__
bin(6) # Return string '0b110', x=int('0b110', base=2)
list(x) # No __list__ but convertible if iterable
===============================================
====== Binary/ranges
=== cpp
// The standard don't fix precise size but usually:
// Type       | Bits | Bytes  |    Max val
// char          8       1        127 / 255
// short (int)  16       2         32,000
// int/long     32       4   2,000,000,000 (billion)
// long long    64       8          10^19
// float        32       4         10^+/-38
// double       64       8        10^+/-300

// Fixed-size available:
uint8_t // u for unsigned
int64_t // 8, 16, 32 and 64 available

size_t length = 1'000'000 * nb_row;  // Warning: the computation is done as int. Risk of overflow !
=== java
=== python
# No precision limit for int (a = 10**100+1 valid)

# For better precision on decimals
decimal.getcontext().prec = decimal.MAX_PREC
decimal.Decimals('3.142342423452')

# Fraction module to keep quotient/denominator

# complex(img, real) type
===============================================
====== Alias/Formatting/alternate representation
=== cpp
// using (C++11: better) vs typedef (old)
typedef void (&FuncType)(int,int);
using FuncType = void(int,int);
template <typename T> using MyType = Whatever<T>;  // Works with template too

10u // Unsigned
10uLL // Unsigned long long
10'000.0 // double // ' since C++14
0.f // Float
0xFF00
0b1101'0100 // 0b since C++14

// TODO:
// Literal operators: Allows conversions (WARNING: NOT MEMBERS, must begin by underscore)
std::string operator "" _w(const char16_t*, size_t);
// Use:  u”Hello”_w // (u is for utf16)
=== java
=== python
1_000.0  # _ since python 3.6

'%s %d' % ('hi', 3)  # Old python formatting
'{} {}'.format('hi', [3, 1])  # 'hi [3, None]'
f'{value+1} {}'  # python 3.6
'{var1} {var1} {:.1f} {padded:0>9} {p[key]}'.format(
    3.14,  # Without the f, it can use  scientific notation: 3e+00
    padded=123,  # {:>9} pad with space, ^ center, < right pad
    var1='reused',
    p={'key':'val'}  # Works with list too and class '{a.attr}'
)  # 'reused reused 3.1 000000123 val'
'{{}}'  # Double {{ to escape
'{:#x}'.format(123)  # '0x7b' ; x for Hex repr, # to add 0x
===============================================
====== Operators/Overload
=== cpp
// Associativity: Usually left to right: (((a+b)+c)+d) or ((a<<b)<<c)

// Binary ops:
// AND: &
// OR: |
// NOT: ~
// XOR: ^
// Shift right: >>  // Warning: strong bit is copied (negative stay negative)
// Shift left: <<  // Fill with 0s

// Overloading the operators
A A::operator+(const A& other); // Member version
C operator+(const A& a, const B& b);  // Non-member version

// Others members operators
int operator int()
void operator new
void operator new []
A* operator ->(); // Must return ptr, obj or ref
void operator++(int); // Can accept an argument (ex: x++(3))
void operator[](int index); // Only one arg (contrary to Python), can be anything (ex: string key)
void operator()(Args...);
bool operator >=(const T& other) const; // WARNING: Don't forget const when necessary (comparison operators)

=== java
// No operator overloading in java
=== python
# As C++, most ops are left-associative
# ((a * b) // c) or ((a**b)**c)

**  # __pow__
/  # __truediv__ (diff between 2.6 and py 3)
//  # __floordiv__
@ # __matmul__ (since 3.5, no built-in implement it)
divmod(x, y) # return the pair (x // y, x % y)

def __iadd__(self, other): # +=  (i stand for in-place)
    return self  # Don't forget

def __rsub__(self, other): # right-side ops, allows (4 - my_obj)
# Only used if (4).__sub__(my_obj) don't exist and 4 and my_obj are from different types (what if children ?)

def __neg__(self):  # or __pos__ : Unary ops (ex: a = -x)
def __invert__(self): # for ~ x ; __abs__ or __round__

def __add__(self, other):

def __lt__(self, other):  # lesser than (<) __le__ for <=

def __call__(self, *args, **kwargs):

def __str__(self):

def __getitem__(self, item):  # For x['a',...,3:5]
    # item can be a tuple of the passed arguments, ex: ('a', Ellipsis, slice(3,5,None))
    # Can check if args contains Ellipsis object (same as ...)
    # x:y are converted into `slice` objects (slice(start=, end=, step=))

# __index__() is called by slice to convert objects (ex: np.int32) into int. This operator has been added instead of __int__ to avoid slice with float numbers
===============================================
====== Functions/lambda
=== cpp
// Pointer on functions
void (*name)(int) = fct;

[&] (int attr) -> int {  // In practice the return value can often be automatically deduced
    return attr;
}
[]   // no variables defined. Attempting to use any external variables in the lambda is an error.
[&]   // any external variable is implicitly captured by reference if used
[=, x, &z]   // z is explicitly captured by reference. X by value, Other variables will be captured by value
[this] // Capture the this ptr
// Warning: sometimes need to add keyword mutable (TODO: When ?)

std::function<void(int,int)> f = myFct;
std::bind : Wrap a function with some of its parameters fixed

std::function<void(int)> f = fct; // Store a function
auto f = std::bind(fct, 42, std::placeholders::_1);  // Prefer lambda instead
=== java
// Anonymous classes
someObject.addMouseListener(new MouseAdapter() {
    @override
    public void mouseClicked(MouseEvent e) {
        ...//Event listener implementation goes here...
    }
});
// Other common pattern
someObject.addMouseListener(this);

// On Java 8, lambda have been added
.map(p -> p.getEmailAddress())
t -> {return t+1;}
=== python
def a(x):
   return 3
b = a
b = lambda x : 3  # Same but PEP8 discourage the use of lambda (stack trace more difficult to debug)

# Equivalent of std::bind
new_fct = functools.partial(fct, arg1, arg2, pos=arg3)
================================================================================
========= Collections
===============================================
====== Iterators
=== cpp
// Concepts:
// ForwardIterator (just +)
// BidirectionalIterator (iter - 5 valid)
// RandomAccessIterator (cst access to any elems)


while(v.begin() != v.end()){} // Warning: != and not <
v.rbegin() // Reverse iterator (should be compared with .rend())
=== java
// implement Iterable, override:
// .iterator()
// boolean .hasNext()
// Item .next()
// .remove()
=== python
i = iter([1, 2, 3, 4])
x = next(i)  # Or i.__next__() for 3.x, i.next() for 2.6 : Return elem (not yield)
i.__length_hint__()  # ==3 : Nb of elem left, optional

# To create own iterator:
# Either overload __iter__(self) as a generator (yield)
# Either __iter__ return an object (potentially self) which overload __next__

# Iters have 2nd arg for sentinel value (exit if encounter), first arg should be callable function
for c in iter(my_fct, ''):  # Exit when my_fct return ''
    var.append(c)

# Generators
def f():
   for i in range(10):
      yield i
gen = f()  # Return instantaneously
next(gen)  # Execute the function up to the next yield
# Raise StopIteration when finished
===============================================
====== Vector
=== cpp
std::vector<T> v;
std::array<T, N> v; // Since C++11, in practice more trouble (ex:array of array), only use when perfs critical

std::bitset<sizeof(int)*8> bits; // Array of bits
=== java
ArrayList<int> list;
Obj v.get(index)
.set(index, Obj)

.add(index, Obj)
.add(Obj)  // end of list
.addAll(index, Collection)

Obj .remove(int index)
boolean .remove(iObj obj)
=== python
my_list = []

list = [0] * desired_length

.extend(collection)
===============================================
====== List/queues
=== cpp
std::list<T> l = {1, 2, 3}; // Double linked list (O(1) time remove any elem)
std::deque<T> l; // O(1) time for random access
std::forward_list<T> l; // C++11

=== java
Stack<Item> s;
= s.pop()
s.push(Item);

Queue<Item> q;
q.enqueue(Item);
= q.dequeue();

LinkedList
.add
.addAll
.addFirst(Obj)
.addLast(Obj)
.get(index)
.getFirst()
.getLast()
// As Stack
.push(Obj)
.pop()
//
Obj .removeFirst()
=== python
q = collections.deque([1, 2, 3])
x = q.popleft()  # or appendleft
===============================================
====== HashTable
=== cpp
/ Keep order (o(logn)) retrieval
std::map<string, int> map;

// Hash table: o(1) lookup
std::unordered_map<string, int> umap;


// Check elem presence
.count(key); // return 0 or 1 for map
.find(key); // return iterator if found, map::end otherwise

// Set, map, unordered_map, …
.insert(std::pair<K,V>(k, v));
.emplace(std::make_pair(k, v)); // converting move constructor
.emplace(k, v); // uses pair's template constructor
// Warning: Value initialized if not exist (int:0, bool:false)
[“key”] = val; // Will create the key if not exist
.at(key); // out_of_range exception if not exist
.erase(k)// Either key, iter or (begin(), end())

// Iterate over unorered_map
for (pair<K,V>& next : mapObj) ...;

for (auto&& [ k, v ] : get_map())  // C++17 allows structured bindings
    std::cout << "k=" << k << " v=" << v << '\n';

// To use a custom class Key, you need:
//  * a class which overload operator == (to handle collisions)
//  * a custom hash (overload std):
namespace std
{
    template<> struct hash<K>
    {
        std::size_t operator()(K const& k) const
        {
           // Don't forget {} when declaring the hash (hash{}(x))
            std::size_t const h1 ( std::hash<std::string>{}(k.x1) );
            std::size_t const h2 ( std::hash<int>{}(k.x2) );
            return h1 ^ (h2 << 1); // or use boost::hash_combine
        }
    };
}
=== java
HashMap<K,V>
.put(key, value);
.get(key)
.containsKey(K key)
.containsValue(V value)
.values()
.keySet()

// Custom hash
@Override
public int hashCode() {
    int hash = 7; // Use prime number (less collisions)
    for (int i = 0; i < strlen; i++) {
        hash = hash*31 + charAt(i);
    }
}
=== python
.items()
.keys()

# Return the values
get(key[, default])  # Don't modify the dict
setdefault(key[, default])  # Set if not present

pop(key[, default])
popitem() // Remove arbitrary item (atomic: thread-safe)
del my_dict['key']

# Merge 2 dicts
.update(other)

d = collections.defaultdict(list)  # Initialize the new keys with list()
d['new_key'].append(x)

c = collections.Counter(['a', 'a', 'b'])
c['d'] # = 0
c.most_common(1)  # = [('a', 2)]

collections.OrderedDict([items])  # Keep order
collections.defaultdict(factory)  # Use factory() to initialize elem if not exits

# ---- Sets: Warning: ----
#   set       VS       dictionary
{1, 2, 3}     VS  {1:'2', 2:'2', 4:'4'}
set()         VS  {}
a = set()
a |= {1, 2, 3}  # += Don't exist, neither .extend()
a.add(2)  # Single elem only
a.remove(2)
a.pop() # Choose random elem
# Other ops &= (intersection), ^= (exclude comuns), -=
# set can be compared (<: incude, <=, .isdisjoint(other))

def __hash__(self): # Custom hash, by default hash(f(id(obj)))
    return hash((self.a, self.b))  # tuple are hashable
===============================================
====== Other
=== cpp
// Structure binding (works with tuple, struct, pair)
// unpack the tuple into individual variables declared at the call site
auto [ i, s ] = std::make_tuple(123, 'test'); // C++ 17
=== java
=== python
# Tuple:
(a,e,t)
(singleton,)  # Warning: ending comma ,

# namedtuple
Color = collections.namedtuple('Color', ['r', 'g', 'b'])
c = Color(255, 0, 124)
===============================================
====== Common collections methods
=== cpp
=== java
=== python
================================================================================
========= Class
===============================================
====== Constructors and Inheritance
=== cpp
class A : public B, protected C
// All public C member will be protected on A
{
public:
    A() : B("str"), C(), m_attr(2)
    {
    }
    explicit A(int a); // Avoid implicit conversions:
    // A a = 3; // Illegal
    // A a = {3}; // Illegal (use A a{3} instead)
    // ...

    A() = default; // Explicitly generated by compiler
    A() = delete;  // Better than declaring private

    // WARNING: Automatically generated if no constructor:
    A();               // Default constructor
    A(const A&);       // Copy constructor
    A& op=(const A&);  // Copy assignment operator
    ~A();              // Destructor
    A(A&&);            // Move constructor
    A& operator=(A&& a)// Move assignment operator
    {
        // (doesn't allocate new resources)
        m_a = std::move(a.m_a);
        return *this;
    }
    // copy and move assignment operator return *this

    A(std::initializer_list<T> args); // Called with {} (ex: A a{})

    // Warning:
    A a = a2; // Call copy cst
    A a = 3; // Call A(int) except if declared explicit)
};
=== java
public class A extends MyParent implement MyInterface
{
    public A() {
        super(); // Call parent constructor
    }

    // static/class initializer
    private static final int a;
    static { // static/Class initializer (called once globally)
        a = 5;
        doSomething(a);
    }

    private final int b;  // Final has to be initialized before the end of the initializer block
    { // Instance initializer (called before constructor)
        b = 5;
    }

    private static int doSomething(int x)
    {...}

}  // No ending ;
=== python
class A(B, C, metaclass=D):

    def __init__(self):
        super().__init__()
        # B.__init__('str')  explicit possible if multiple parents

    # Reduce use of metaclass (since 3.6)
    def __init_subclass__(cls, **kwargs):
      super().__init_subclass__(**kwargs)

    # Using metaclass:
    __metaclass__ = MyMeta  # Python 2
    # python 3 use class A(metaclass=ABCMeta):
    # Effect:
    # A = MyMeta(name, bases, dct_attrs) # Use custom...
    # A = type('A', (B,C), attrs) # ...instead of standard

    class MyMeta(type): # Metaclasses should implement new and init
        def __init__(cls, name, bases, dct):
            super().__init__(name, bases, dct)
        def __call__(cls, *args,**kwargs):
            return super().__new__(meta, name, bases, dct)

# Warning: The super method name resolution order for python inheritance is different from C++. By calling super, you can call a method that you don't directly inherit.
===============================================
====== Static methods
=== cpp
static bool foo()
{
    // Called with A::foo();
}

// Static attributes need to be initialized in the .cpp file to avoid linker errors
=== java
public static boolean foo() {
  super.foo();  // Call parent (foo static)
  B.foo(); // Explicit call (ex: if conflict)
}
=== python
@classmethod
def meth1(cls):  # cls can be a child class
    pass

@staticmethod
def meth2():
    pass
===============================================
====== Class to string
=== cpp
ostream& operator<<(ostream& os, const Obj& obj)
{
    // Fct usually declared as friend to allow member access
    os << "<" << obj.a << '-' << obj.b << '>';
    return os;
}
=== java
String toString() {
    return "fct";
}
// What else ?
=== python
def ___str__(self):  # Called when print(obj), '{}'.format(obj), str(obj)
def __repr__(self):  # Called when print([obj]), repr(obj)
===============================================
====== Getter/setters
=== cpp
=== java
=== python
@property  # Act as public attribute (e = my_obj.email)
def email(self):
    return self.__email

@email.setter  # Note the variable name
def email(self, new_val):
    self.__email = new_val
===============================================
====== Abstract methods
=== cpp
virtual void b() {} // Implemented here
void a() = 0; // virtual pure (abstract class)
void a() final; // Explicitly forbidden override
void b() override; // Explicitly require parent virtual

// WARNING: Declare destructor VIRTUAL
=== java
public interface Foo {
    public void doSomething();
    // No implementations possible ?
    public void doSomethingElse();
    // Can interface have attribute ?
}
// Class which implement interface must implement ALL method (Java 8: default method possible)

// Notice keyword abstract
public abstract class GraphicObject {
    // declare fields
    // declare nonabstract methods
    // declare abstract methods:
    abstract void draw();
}

@override
public void foo()
{}
=== python
# Declare abstract class
__metaclass__ = abc.ABCMeta

@abc.abstractmethod
def virual_fct(self):
    pass  # Raise an error at 'compile time' if not implemented
===============================================
====== Other
=== cpp
friend void externalFct(int, char);
friend class Other;
// Friends are not inherited
=== java
=== python
# Mangle variables name (useful to avoid name conflict with child class)
self.__var = 1  # Name outside the class becomes obj._A__var

MyClass.__dict__.keys() == ['_MyClass__var', ...]  # Access all members/attributes of a class
vars(obj)  # Should be prefered. Return ref on __dict__ . Warning: instances have an updateable __dict__ attribute but not classes

hasattr(obj, name)
getattr(obj, name[, default])
setattr(obj, name, value)  # obj.name = value (create or update)
delattr(obj, name)  # del obj.name

__slots__ = ['x', 'y']  # Optimize the class (reduce the memory allocation for each instance)
================================================================================
========= Other
===============================================
====== Thread and concurency
=== cpp
// Low level: launch a callable (fct, fct Obj, lambda)
std::thread threadObj(thread_function);
threadObj.join();


std::mutex m_mutex; // No need for initialization as in C
std::lock_guard<std::mutex> lock(m_mutex); // Avoid concurrent calls

// unique_lock like lock_guard (automatically released when destroyed) but can be lock/try_lock/unlocked multiple times

// Use condition_variable with notify_one or notify_all
std::unique_lock<std::mutex> guard(cv_mutex);
cv.wait(guard, [](){ return condition == true;});
condition = false; // No effect if notify_all (vs notify_one)
// cv_wait Will block while the condition is not fulfill (without locking the mutex. Will lock the mutex when the condition is fulfill) (only one execute at a time, even with notify_all. Notify all just make all thread checking the condition at the same times, all will be released even if just one at the time will get the mutex)

// High level:
std::promise<void> p;
std::future<void> f = p.get_future();
// In some thread: p.set_value(); // No args for <void>
f.wait() // or f.get() if not <void>

// Packaged task mix promise and task function
std:packaged_task<int(int,int)> pt1(fct_add);
std::thread{std::move(pt1), arg1, arg2} // Launch thread
pt1.get_future().get();

// Async: Combine thread and packaged task
std::future f = std::async(fct, arg1);  // WARNING: blocking if we don't capture the returned future

std::atomic<char> x; // Read/write are thread safe
=== java
=== python
===============================================
====== Random numbers / Maths
=== cpp
std::random_device rd;
std::mt19937 gen(rd());
std::uniform_int_distribution<> dis(0, max_included);

int number = dis(gen);  // TODO: How to generate random numbers without having to forwards two variables (dis and gen) ?

// Floor a number to x decimal
int a = static_cast<int>(d*precision); // (int precision = 1000)
double q = static_cast<float>(a)/precision;

// float = int / int; // float will be truncated (ex: float a = 5/2; vs 5.f / 2)
// float = float/int or int/float; int implicitly converted to float before div
=== java
=== python
x = random.randrange(10)  # [0, 9]
x = random.randint(0,10)  # [0,10] (WARNING: confusion with np.randint() where max is excusive)

math.isclose(a, b)  # float equality (since 3.4)

round(x, 2) # Round to 2 decimal points
===============================================
====== Language specificities
=== cpp
// Copy elision: Optimize copy/move constructor
T x = T(T(T())); // only one call to default constructor of T, to initialize x

// Named return Value Optimisation:
T f()
{
    T t;
    return t;  // most likely elided entirely
    return std::move(t);  // uses T::T(T &&) if defined; error if deleted or inaccessible
    return static_cast<T&>(t)  // uses T::T(T const &)
}
=== java
=== python
# Context managers
with MyContext() as c:  # Call MyContext.__enter__ and .__exit__
   pass

@contextlib.contextmanager # Wrap __enter__, __exit__
def my_context():
    try:
        yield  # must yield one exactly (the yield value is caught by `as`)
        # Close code is after (generally catching exceptions)
    finally:  # Called even if called return within the context manager
        pass

================================================================================
========= Other
===============================================
====== Example
=== cpp
=== java
=== python
