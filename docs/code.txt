================================================================================
========= Base code
===============================================
====== Hello world
=== cpp
#import <iostream>
#import <cstdio>
#import <vector>

int foo(const std::vector& v)
{
    for(size_t i = 0 ; i < v.size() ; ++i)
    {}
    return 0;
}

int main(int argc, char** argv)
{
    std::cout << "Hello " << 4 << " humans"<< std::endl;
    printf("Hello %d %s\n", 4, "humans");
    return 0; // EXIT_SUCCESS (defined in stdlib)
}
=== java
import java.lang.Math;

public class HelloWorld
{
    public static void main (String[] args)  // WARNING: think PUBLIC, think STATIC
    {
        System.out.println("Hello");
    }
}

// WARNING: == compare refs, not values (ex: String). No operators overloading

=== python
if __name__ == '__main__':
    print('Hello {} humans'.format(4))
===============================================
====== Loops
=== cpp
for (const std::string& s : myList)
{
}
for(auto x : v); // Work with copy
for(auto& x : v);
for(auto const& : v); // Work with const reference

continue;
break;
=== java
for (String s : myList) {
}

continue;
break;
=== python
for x in my_list:
    if x == target:
        break
else:  # No break or empty list
    print('target not found')

for i in range(100):  # xrange for 2.6
    pass

continue
break
===============================================
====== Switch
=== cpp
switch (value)  // Only works with integer (or enums)
{
    case 1:
        // ...
        break;
    default:
        // ...
}
=== java
switch (month)  // Also works with String
{
    case "January":
        // ...
        break;
    default:
        // ...
}
=== python
================================================================================
========= Primitives, operators
===============================================
====== Primitives
=== cpp
bool b = true;
std::string s = "Hello";
=== java
boolean b = true;
String s = "Hello"
=== python
b = True
s = 'Hello'

# Types: bool, str, int, float, list, tuple, dict, set,...
===============================================
====== Enum
=== cpp
enum e {a, b, c=3}; // enum class in C++11
=== java
public enum Day {MONDAY, TUESDAY} // No ;
=== python
class Day(enum.Enum):  # Since 3.4
    MON = enum.auto()
    TUE = enum.auto()  # auto() since 3.6, before, explicit was better than implicit...

Day = enum.Enum('Day', 'MON, TUE, WED')  # as collections.namedtuple

Mode = enum.Flag('Mode', 'r, w')  # Since 3.6, Flags compatible with &, |, ^, ~
====== Type checking and deduction
=== cpp
decltype(a->x) y;   // type of y is double (declared type)
decltype((a->x)) z = y; // type of z is const double& (lvalue expression)
=== java
=== python
type(o) is str
isinstance(o, str)
===============================================
====== Functions/lambda
=== cpp
std::function<void(int)> f = fct; // Store a function
auto f = std::bind(fct, 42, std::placeholders::_1);  // Prefer lambda instead
=== java
=== python
f = functools.partial(fct, 42, arg2=43)
===============================================
====== ##Formatting/alternate representation
=== cpp
10u // Unsigned
10uLL // Unsigned long long
10'000.0 // double // ' since C++14
0.f // Float
0xFF00
0b1111'0000 // 0b since C++14

size_t length = 1'000'000 * nb_row;  // Warning: the computation is done as int. Risk of overflow !
=== java
=== python
1_000.0  # _ since python 3.6
================================================================================
========= Collections
===============================================
====== Iterators
=== cpp
// Concepts:
// ForwardIterator (just +) and BidirectionalIterator (iter - 5 valid)
// RandomAccessIterator (cst access to any elems)


while(v.begin() != v.end()){} // Warning: != and not <
v.rbegin() // Reverse iterator (should be compared with .rend())
=== java
// implement Iterable, override:
// .iterator()
// boolean .hasNext()
// Item .next()
// .remove()
=== python
i = iter([1, 2, 3, 4])
x = next(i)  # Or i.__next__() for 3.x, i.next() for 2.6 : Return elem (not yield)
i.__length_hint__()  # ==3 : Nb of elem left, optional

# To create own iterator:
# Either overload __iter__(self) as a generator (yield)
# Either __iter__ return an object (potentially self) which overload __next__

# Iters have 2nd arg for sentinel value (exit if encounter), first arg should be callable function
for c in iter(my_fct, ''):  # Exit when my_fct return ''
    var.append(c)

# Generators
def f():
   for i in range(10):
      yield i
gen = f()  # Return instantaneously
next(gen)  # Execute the function up to the next yield
# Raise StopIteration when finished
===============================================
====== Vector
=== cpp
std::vector<T> v;
std::array<T, N> v; // Since C++11, in practice more trouble (ex:array of array), only use when perfs critical

=== java
=== python
my_list = []
===============================================
====== List/queues
=== cpp
std::list<T> l; // Double linked list (O(1) time remove any elem)
std::deque<T> l; // O(1) time for random access
std::forward_list<T> l; // C++11
=== java
Stack<Item> s;
= s.pop()
s.push(Item);

Queue<Item> q;
q.enqueue(Item);
= q.dequeue();

=== python
===============================================
====== HashTable
=== cpp
=== java
=== python
# ---- Sets: Warning: ----
#   set       VS       dictionary
{1, 2, 3}     VS  {1:’2’, 2:’2’, 4:’4’}
set()         VS  {}
a = set()
a |= {1, 2, 3}  # += Don’t exist, neither .extend()
a.add(2)  # Single elem only
a.remove(2)
a.pop() # Choose random elem
# Other ops &= (intersection), ^= (exclude comuns), -=
# set can be compared (<: incude, <=, .isdisjoint(other))

===============================================
====== Other
=== cpp
=== java
=== python
# Tuple:
(a,e,t)
(singleton,)  # Warning: ending comma ,

# namedtuple
Color = collections.namedtuple('Color', ['r', 'g', 'b'])
c = Color(255, 0, 124)
===============================================
====== Common collections methods
=== cpp
=== java
=== python
================================================================================
========= Other
===============================================
====== Example
=== cpp
=== java
=== python
