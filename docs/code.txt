================================================================================
========= Base code
===============================================
====== Hello world
=== cpp
#import <iostream>
#import <cstdio>
#import <vector>

int foo(const std::vector& v)
{
    for(size_t i = 0 ; i < v.size() ; ++i)
    {}
    return 0;
}

int main(int argc, char** argv)
{
    std::cout << "Hello " << 4 << " humans"<< std::endl;
    printf("Hello %d %s\n", 4, "humans");
    return 0; // EXIT_SUCCESS (defined in stdlib)
}
=== java
import java.lang.Math;

public class HelloWorld
{
    public static void main (String[] args)  // WARNING: public and static keywords
    {
        System.out.println("Hello");
    }
}

// WARNING: == compare refs, not values (ex: String). No operators overloading

=== python
if __name__ == '__main__':
    print('Hello {} humans'.format(4))
===============================================
====== Loops
=== cpp
for (const std::string& s : myList)
{
}
for(auto x : v); // Work with copy
for(auto& x : v);
for(auto const& : v); // Work with const reference

continue;
break;
=== java
for (String s : myList) {
}

continue;
break;
=== python
# For loops have an else clause
for x in my_list:
    if x == target:
        break
else:  # No break or empty list
    print('target not found')

for i in range(100):  # xrange for 2.6
    pass

continue
break
===============================================
====== Switch
=== cpp
switch (value)  // Only works with integer (or enums)
{
    case 1:
        // ...
        break;
    default:
        // ...
}
=== java
switch (month)  // Also works with String
{
    case "January":
        // ...
        break;
    default:
        // ...
}
=== python
================================================================================
========= Primitives, operators
===============================================
====== Primitives
=== cpp
bool b = true;
std::string s = "Hello";

std::optional<std::string> var; // Can be a string or a not value (like None in python) C++17
var.value_or("default"); // .has_value() ; .value()
=== java
boolean b = true;
String s = "Hello"
=== python
b = True
s = 'Hello'

z = complex(1, 4)  # = 1 + 4j

# Types: bool, str, int, float, list, tuple, dict, set,...
===============================================
====== Enum
=== cpp
enum e {a, b, c=a+3}; // start at 0, then +1
enum class e {a, b, c}; // strongly typed in C++11
=== java
public enum Day {MONDAY, TUESDAY} // No custom values;
=== python
class Day(enum.Enum):  # Since 3.4
    MON = enum.auto()
    TUE = enum.auto()  # auto() since 3.6, before, explicit was better than implicit...

Day = enum.Enum('Day', 'MON, TUE, WED')  # as collections.namedtuple

Mode = enum.Flag('Mode', 'r, w')  # Since 3.6, Flags compatible with &, |, ^, ~
====== Type checking and deduction
=== cpp
decltype(a->x) y;   // type of y is double (declared type)
decltype((a->x)) z = y; // type of z is const double& (lvalue expression)

// When return type depends on template parameters
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u)
{
}

// Type checking (statically at compile time)
std::is_same<T1, T2>::value // Or is_same_v<T> since C++14
std::remove_reference<int>::type // Or remove_reference_t<T>
=== java
=== python
type(o) is str
isinstance(o, str)
===============================================
====== Casting
=== cpp
// Cast
static_cast<>(x) // Standard conversion (ex: double to float)
reinterpret_cast<>(x) // Bits don’t change (ex: char* to int*)
const_cast<>(c)
dynamic_cast<>(); // For inheritance

// To overload cast
explicit operator bool () const; // explicit prevent bool a = obj
operator int* () const; // Note the absence of return value in the signature
operator MyType () const; // Custom cast
=== java
float newVar = (float)oldVar; // C like syntax
=== python
str(x)
int(x) # associated __int__(self) to overload
float(x) # __float__
bin(6) # Return string '0b110', x=int('0b110', base=2)
list(x) # No __list__ but convertible if iterable
===============================================
====== Binary/ranges
=== cpp
// The standard don't fix precise size but usually:
// Type       | Bits | Bytes  |    Max val
// char          8       1        127 / 255
// short (int)  16       2         32,000
// int/long     32       4   2,000,000,000 (billion)
// long long    64       8          10^19
// float        32       4         10^+/-38
// double       64       8        10^+/-300

// Fixed-size available:
uint8_t // u for unsigned
int64_t // 8, 16, 32 and 64 available

=== java
=== python
# No precision limit for int (a = 10**100+1 valid)

# For better precision on decimals
decimal.getcontext().prec = decimal.MAX_PREC
decimal.Decimals('3.142342423452')

# Fraction module to keep quotient/denominator

# complex(img, real) type
===============================================
====== Operators/Overload
=== cpp
// Associativity: Usually left to right: (((a+b)+c)+d) or ((a<<b)<<c)

// Binary ops:
// AND: &
// OR: |
// NOT: ~
// XOR: ^
// Shift right: >>  // Warning: strong bit is copied (negative stay negative)
// Shift left: <<  // Fill with 0s

// Overloading the operators
A A::operator+(const A& other); // Member version
C operator+(const A& a, const B& b);  // Non-member version

// Others members operators
int operator int()
void operator new
void operator new []
A* operator ->(); // Must return ptr, obj or ref
void operator++(int); // Can accept an argument (ex: x++(3))
void operator[](int index); // Only one arg (contrary to Python), can be anything (ex: string key)
void operator()(Args...);
bool operator >=(const T& other) const; // WARNING: Don't forget const when necessary (comparison operators)

=== java
// No operator overloading in java
=== python
# As C++, most ops are left-associative
# ((a * b) // c) or ((a**b)**c)

**  # __pow__
/  # __truediv__ (diff between 2.6 and py 3)
//  # __floordiv__
@ # __matmul__ (since 3.5, no built-in implement it)
divmod(x, y) # return the pair (x // y, x % y)

def __iadd__(self, other): # +=  (i stand for in-place)
    return self  # Don't forget

# right-side ops, ex: __rsub__ allows (4 - my_obj)
#   - only used if (4).__sub__(my_obj) don't exist
#   - and 4 and my_obj are from different types (what if children ?)

def __neg__(self):  # or __pos__ : Unary ops (ex: a = -x)
def __invert__(self): # for ~ x ; __abs__ or __round__

def __add__(self, other):

def __lt__(self, other):  # lesser than (<) __le__ for <=

def __call__(self, *args, **kwargs):

def __str__(self):

def __getitem__(self, item):  # For x['a',...,3:5]
    # item can be a tuple of the passed arguments, ex: ('a', Ellipsis, slice(3,5,None))
    # Can check if args contains Ellipsis object (same as ...)
    # x:y are converted into `slice` objects (slice(start=, end=, step=))

# __index__() is called by slice to convert objects (ex: np.int32) into int. This operator has been added instead of __int__ to avoid slice with float numbers
===============================================
====== Functions/lambda
=== cpp
// Pointer on functions
void (*name)(int) = fct;

[&] (int attr) -> int {  // In practice the return value can often be automatically deduced
    return attr;
}
[]   // no variables defined. Attempting to use any external variables in the lambda is an error.
[&]   // any external variable is implicitly captured by reference if used
[=, x, &z]   // z is explicitly captured by reference. X by value, Other variables will be captured by value
[this] // Capture the this ptr
// Warning: sometimes need to add keyword mutable (TODO: When ?)

std::function<void(int,int)> f = myFct;
std::bind : Wrap a function with some of its parameters fixed

std::function<void(int)> f = fct; // Store a function
auto f = std::bind(fct, 42, std::placeholders::_1);  // Prefer lambda instead
=== java
// Anonymous classes
someObject.addMouseListener(new MouseAdapter() {
    @override
    public void mouseClicked(MouseEvent e) {
        ...//Event listener implementation goes here...
    }
});
// Other common pattern
someObject.addMouseListener(this);

// On Java 8, lambda have been added
.map(p -> p.getEmailAddress())
t -> {return t+1;}
=== python
def a(x):
   return 3
b = a
b = lambda x : 3  # Same but PEP8 discourage the use of lambda (stack trace more difficult to debug)

# Equivalent of std::bind
new_fct = functools.partial(fct, arg1, arg2, pos=arg3)
===============================================
====== ##Formatting/alternate representation
=== cpp
10u // Unsigned
10uLL // Unsigned long long
10'000.0 // double // ' since C++14
0.f // Float
0xFF00
0b1101'0100 // 0b since C++14

// TODO:
// Literal operators: Allows conversions (WARNING: NOT MEMBERS, must begin by underscore)
std::string operator "" _w(const char16_t*, size_t);
// Use:  u”Hello”_w // (u is for utf16)

size_t length = 1'000'000 * nb_row;  // Warning: the computation is done as int. Risk of overflow !
=== java
=== python
1_000.0  # _ since python 3.6
================================================================================
========= Collections
===============================================
====== Iterators
=== cpp
// Concepts:
// ForwardIterator (just +)
// BidirectionalIterator (iter - 5 valid)
// RandomAccessIterator (cst access to any elems)


while(v.begin() != v.end()){} // Warning: != and not <
v.rbegin() // Reverse iterator (should be compared with .rend())
=== java
// implement Iterable, override:
// .iterator()
// boolean .hasNext()
// Item .next()
// .remove()
=== python
i = iter([1, 2, 3, 4])
x = next(i)  # Or i.__next__() for 3.x, i.next() for 2.6 : Return elem (not yield)
i.__length_hint__()  # ==3 : Nb of elem left, optional

# To create own iterator:
# Either overload __iter__(self) as a generator (yield)
# Either __iter__ return an object (potentially self) which overload __next__

# Iters have 2nd arg for sentinel value (exit if encounter), first arg should be callable function
for c in iter(my_fct, ''):  # Exit when my_fct return ''
    var.append(c)

# Generators
def f():
   for i in range(10):
      yield i
gen = f()  # Return instantaneously
next(gen)  # Execute the function up to the next yield
# Raise StopIteration when finished
===============================================
====== Vector
=== cpp
std::vector<T> v;
std::array<T, N> v; // Since C++11, in practice more trouble (ex:array of array), only use when perfs critical

=== java
=== python
my_list = []
===============================================
====== List/queues
=== cpp
std::list<T> l; // Double linked list (O(1) time remove any elem)
std::deque<T> l; // O(1) time for random access
std::forward_list<T> l; // C++11
=== java
Stack<Item> s;
= s.pop()
s.push(Item);

Queue<Item> q;
q.enqueue(Item);
= q.dequeue();

=== python
===============================================
====== HashTable
=== cpp
=== java

// Custom hash
@Override
public int hashCode() {
    int hash = 7; // Use prime number (less collisions)
    for (int i = 0; i < strlen; i++) {
        hash = hash*31 + charAt(i);
    }
}
=== python
# ---- Sets: Warning: ----
#   set       VS       dictionary
{1, 2, 3}     VS  {1:’2’, 2:’2’, 4:’4’}
set()         VS  {}
a = set()
a |= {1, 2, 3}  # += Don’t exist, neither .extend()
a.add(2)  # Single elem only
a.remove(2)
a.pop() # Choose random elem
# Other ops &= (intersection), ^= (exclude comuns), -=
# set can be compared (<: incude, <=, .isdisjoint(other))

# Custom hash with __hash__(self), by default hash(f(id(obj)))
===============================================
====== Other
=== cpp
=== java
=== python
# Tuple:
(a,e,t)
(singleton,)  # Warning: ending comma ,

# namedtuple
Color = collections.namedtuple('Color', ['r', 'g', 'b'])
c = Color(255, 0, 124)
===============================================
====== Common collections methods
=== cpp
=== java
=== python
================================================================================
========= Class
===============================================
====== Constructors and Inheritance
=== cpp
class A : public B, protected C
// All public C member will be protected on A
{
public:
    A() : B("str"), C(), m_attr(2)
    {
    }
    explicit A(int a); // Avoid implicit conversions:
    // A a = 3; // Illegal
    // A a = {3}; // Illegal (use A a{3} instead)
    // ...

    A() = default; // Explicitly generated by compiler
    A() = delete;  // Better than declaring private

    // WARNING: Automatically generated if no constructor:
    A();               // Default constructor
    A(const A&);       // Copy constructor
    A& op=(const A&);  // Copy assignment operator
    ~A();              // Destructor
    A(A&&);            // Move constructor
    A& operator=(A&& a)// Move assignment operator
    {
        // (doesn’t allocate new resources)
        m_a = std::move(a.m_a);
        return *this;
    }
    // copy and move assignment operator return *this

    A(std::initializer_list<T> args); // Called with {} (ex: A a{})

    // Warning:
    A a = a2; // Call copy cst
    A a = 3; // Call A(int) except if declared explicit)
};
=== java
public class A extends MyParent implement MyInterface
{
    public A() {
        super(); // Call parent constructor
    }

    // static/class initializer
    private static final int a;
    static { // static/Class initializer (called once globally)
        a = 5;
        doSomething(a);
    }

    private final int b;  // Final has to be initialized before the end of the initializer block
    { // Instance initializer (called before constructor)
        b = 5;
    }

    private static int doSomething(int x)
    {...}

}  // No ending ;
=== python
class A(B, C, metaclass=D):

    def __init__(self):
        super().__init__()
        # B.__init__('str')  explicit possible if multiple parents

    # Reduce use of metaclass (since 3.6)
    def __init_subclass__(cls, **kwargs):
      super().__init_subclass__(**kwargs)

    # Using metaclass:
    __metaclass__ = MyMeta  # Python 2
    # python 3 use class A(metaclass=ABCMeta):
    # Effect:
    # A = MyMeta(name, bases, dct_attrs) # Use custom...
    # A = type('A', (B,C), attrs) # ...instead of standard

    class MyMeta(type): # Metaclasses should implement new and init
        def __init__(cls, name, bases, dct):
            super().__init__(name, bases, dct)
        def __call__(cls, *args,**kwargs):
            return super().__new__(meta, name, bases, dct)

# Warning: The super method name resolution order for python inheritance is different from C++. By calling super, you can call a method that you don't directly inherit.
===============================================
====== Static methods
=== cpp
static bool foo()
{
    // Called with A::foo();
}

// Static attributes need to be initialized in the .cpp file to avoid linker errors
=== java
public static boolean foo() {
  super.foo();  // Call parent (foo static)
  B.foo(); // Explicit call (ex: if conflict)
}
=== python
@classmethod
def meth1(cls):  # cls can be a child class
    pass

@staticmethod
def meth2():
    pass
===============================================
====== Getter/setters
=== cpp
=== java
=== python
@property  # Act as public attribute (e = my_obj.email)
def email(self):
    return self.__email

@email.setter  # Note the variable name
def email(self, new_val):
    self.__email = new_val
===============================================
====== Abstract methods
=== cpp
virtual void b() {} // Implemented here
void a () = 0; // virtual pure (abstract class)
void a () final; // Explicitly forbidden override
void b() override; // Explicitly require parent virtual

// WARNING: Declare constructor VIRTUAL
=== java
public interface Foo {
    public void doSomething();
    // No implementations possible ?
    public void doSomethingElse();
    // Can interface have attribute ?
}
// Class which implement interface must implement ALL method (Java 8: default method possible)

// Notice keyword abstract
public abstract class GraphicObject {
    // declare fields
    // declare nonabstract methods
    // declare abstract methods:
    abstract void draw();
}

@override
public void foo()
{}
=== python
# Declare abstract class
__metaclass__ = abc.ABCMeta

@abc.abstractmethod
def virual_fct(self):
    pass  # Raise an error at 'compile time' if not implemented
===============================================
====== Other
=== cpp
friend void externalFct(int, char);
friend class Other;
// Friends are not inherited
=== java
=== python
# Mangle variables name (useful to avoid name conflict with child class)
self.__var = 1  # Name outside the class becomes obj._A__var

MyClass.__dict__.keys() == ['_MyClass__var', ...]  # Access all members/attributes of a class
hasattr(cls, name)
getattr(cls, name)

__slots__ = ['x', 'y']  # Optimize the class (reduce the memory allocation for each instance)
================================================================================
========= Other
===============================================
====== Exceptions
=== cpp
try
{
    throw Exception();  // In C++, exceptions can be any objects (int,...)
    // common to inherit from std::exception and override const char* what()
}
catch (Exception& e)  // Can only catch one exception
{
    cout << e.what() << endl;
}
catch (...)
{
    // Default exception
} // No finally in c++
=== java
try{
    // If return here, the value is stored, then finally is called, then the stored value is returned
} catch(ArrayIndexOutOfBoundsException e) {
    // ...
} catch(IOException|SQLException e) { // Catch 2 exceptions
    e.printStackTrace();
}catch(Exception e){
    // ...
} finally {
    // ...
}

// If not surrounded by try {} catch {}, the function must explicitly declare: throw

void f() throw E // E inherit of Exception extends Throwable
{
}

// Throwable is the interface (Should not be catch (except eventually in main() ))
// Exception is the class
=== python
try:
    raise AttributeError
except IOError as e:  # (KeyboardInterrupt, EOFError) as e:  # For multiple exceptions at once
    pass
except: # OR: except Exception as e:
    pass
else: # If no exceptions
    pass
finally: # In any case (even if return statement)
    pass

===============================================
====== Thread and concurency
=== cpp
// Low level: launch a callable (fct, fct Obj, lambda)
std::thread threadObj(thread_function);
threadObj.join();


std::mutex m_mutex; // No need for initialization as in C
std::lock_guard<std::mutex> lock(m_mutex); // Avoid concurrent calls

// unique_lock like lock_guard (automatically released when destroyed) but can be lock/try_lock/unlocked multiple times

// Use condition_variable with notify_one or notify_all
std::unique_lock<std::mutex> guard(cv_mutex);
cv.wait(guard, [](){ return condition == true;});
condition = false; // No effect if notify_all (vs notify_one)
// cv_wait Will block while the condition is not fulfill (without locking the mutex. Will lock the mutex when the condition is fulfill) (only one execute at a time, even with notify_all. Notify all just make all thread checking the condition at the same times, all will be released even if just one at the time will get the mutex)

// High level:
std::promise<void> p;
std::future<void> f = p.get_future();
// In some thread: p.set_value(); // No args for <void>
f.wait() // or f.get() if not <void>

// Packaged task mix promise and task function
std:packaged_task<int(int,int)> pt1(fct_add);
std::thread{std::move(pt1), arg1, arg2} // Launch thread
pt1.get_future().get();

// Async: Combine thread and packaged task
std::future f = std::async(fct, arg1);  // WARNING: blocking if we don't capture the returned future

std::atomic<char> x; // Read/write are thread safe
=== java
=== python
===============================================
====== Random numbers / Maths
=== cpp
std::random_device rd;
std::mt19937 gen(rd());
std::uniform_int_distribution<> dis(0, max_included);

int number = dis(gen);  // TODO: How to generate random numbers without having to forwards two variables (dis and gen) ?

// Floor a number to x decimal
int a = static_cast<int>(d*precision); // (int precision = 1000)
double q = static_cast<float>(a)/precision;

// float = int / int; // float will be truncated (ex: float a = 5/2; vs 5.f / 2)
// float = float/int or int/float; int implicitly converted to float before div
=== java
=== python
x = random.randrange(10)  # [0, 9]
x = random.randint(0,10)  # [0,10] (WARNING: confusion with np.randint() where max is excusive)

math.isclose(a, b)  # float equality (since 3.4)

round(x, 2) # Round to 2 decimal points
================================================================================
========= Other
===============================================
====== Example
=== cpp
=== java
=== python
