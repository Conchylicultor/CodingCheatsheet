================================================================================
========= Base code
====== Hello world
=== cpp
#import <iostream>
#import <cstdio>
#import <vector>

int foo(const std::vector& v)
{
    for(size_t i = 0 ; i < v.size() ; ++i)
    {}
    return 0;
}

int main(int argc, char** argv)
{
    std::cout << "Hello " << 4 << " humans"<< std::endl;
    printf("Hello %d %s\n", 4, "humans");
    return 0; // EXIT_SUCCESS (defined in stdlib)
}
=== java
import java.lang.Math;

public class HelloWorld
{
    public static void main (String[] args)  // WARNING: think PUBLIC, think STATIC
    {
        System.out.println("Hello");
    }
}

// WARNING: == compare refs, not values (ex: String). No operators overloading

=== python
if __name__ == '__main__':
    print('Hello {} humans'.format(4))
===============================================
====== Loops
=== cpp
for (const std::string& s : myList)
{
}
for(auto x : v); // Work with copy
for(auto& x : v);
for(auto const& : v); // Work with const reference

continue;
break;
=== java
for (String s : myList) {
}

continue;
break;
=== python
for x in my_list:
    if x == target:
        break
else:  # No break or empty list
    print('target not found')

for i in range(100):  # xrange for 2.6
    pass

continue
break
===============================================
====== Switch
=== cpp
switch (value)  // Only works with integer (or enums)
{
    case 1:
        // ...
        break;
    default:
        // ...
}
=== java
switch (month)  // Also works with String
{
    case "January":
        // ...
        break;
    default:
        // ...
}
=== python
================================================================================
========= Primitives, operators
====== Primitives
=== cpp
bool b = true;
std::string s = "Hello";
=== java
boolean b = true;
String s = "Hello"
=== python
b = True
s = 'Hello'

# Types: bool, str, int, float, list, tuple, dict, set,...
===============================================
====== Enum
=== cpp
enum e {a, b, c=3}; // enum class in C++11
=== java
public enum Day {MONDAY, TUESDAY} // No ;
=== python
class Day(enum.Enum):  # Since 3.4
    MON = enum.auto()
    TUE = enum.auto()  # auto() since 3.6, before, explicit was better than implicit...

Day = enum.Enum('Day', 'MON, TUE, WED')  # as collections.namedtuple

Mode = enum.Flag('Mode', 'r, w')  # Since 3.6, Flags compatible with &, |, ^, ~
====== Type checking and deduction
=== cpp
decltype(a->x) y;   // type of y is double (declared type)
decltype((a->x)) z = y; // type of z is const double& (lvalue expression)
=== java
=== python
type(o) is str
isinstance(o, str)
===============================================
====== Functions/lambda
=== cpp
std::function<void(int)> f = fct; // Store a function
auto f = std::bind(fct, 42, std::placeholders::_1);  // Prefer lambda instead
=== java
=== python
f = functools.partial(fct, 42, arg2=43)
===============================================
====== ##Formatting/alternate representation
=== cpp
10u // Unsigned
10uLL // Unsigned long long
10'000.0 // double // ' since C++14
0.f // Float
0xFF00
0b1111'0000 // 0b since C++14

size_t length = 1'000'000 * nb_row;  // Warning: the computation is done as int. Risk of overflow !
=== java
=== python
1_000.0  # _ since python 3.6
========= Other
===============================================
====== Example
=== cpp
=== java
=== python
