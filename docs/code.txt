================================================================================
========= Base code
===============================================
====== Hello world
=== cpp
#import <iostream>
#import <cstdio>
#import <vector>

int foo(const std::vector& v)
{
    for(size_t i = 0 ; i < v.size() ; ++i)
    {}
    return 0;
}

int main(int argc, char** argv)
{
    std::cout << "Hello " << 4 << " humans"<< std::endl;
    printf("Hello %d %s\n", 4, "humans");
    return 0; // EXIT_SUCCESS (defined in stdlib)
}
=== java
import java.lang.Math;

public class HelloWorld
{
    public static void main (String[] args)  // WARNING: think PUBLIC, think STATIC
    {
        System.out.println("Hello");
    }
}

// WARNING: == compare refs, not values (ex: String). No operators overloading

=== python
if __name__ == '__main__':
    print('Hello {} humans'.format(4))
===============================================
====== Loops
=== cpp
for (const std::string& s : myList)
{
}
for(auto x : v); // Work with copy
for(auto& x : v);
for(auto const& : v); // Work with const reference

continue;
break;
=== java
for (String s : myList) {
}

continue;
break;
=== python
# For loops have an else clause
for x in my_list:
    if x == target:
        break
else:  # No break or empty list
    print('target not found')

for i in range(100):  # xrange for 2.6
    pass

continue
break
===============================================
====== Switch
=== cpp
switch (value)  // Only works with integer (or enums)
{
    case 1:
        // ...
        break;
    default:
        // ...
}
=== java
switch (month)  // Also works with String
{
    case "January":
        // ...
        break;
    default:
        // ...
}
=== python
================================================================================
========= Primitives, operators
===============================================
====== Primitives
=== cpp
bool b = true;
std::string s = "Hello";

std::optional<std::string> var; // Can be a string or a not value (like None in python) C++17
var.value_or("default"); // .has_value() ; .value()
=== java
boolean b = true;
String s = "Hello"
=== python
b = True
s = 'Hello'

z = complex(1, 4)  # = 1 + 4j

# Types: bool, str, int, float, list, tuple, dict, set,...
===============================================
====== Enum
=== cpp
enum e {a, b, c=a+3}; // start at 0, then +1
enum class e {a, b, c}; // strongly typed in C++11
=== java
public enum Day {MONDAY, TUESDAY} // No custom values;
=== python
class Day(enum.Enum):  # Since 3.4
    MON = enum.auto()
    TUE = enum.auto()  # auto() since 3.6, before, explicit was better than implicit...

Day = enum.Enum('Day', 'MON, TUE, WED')  # as collections.namedtuple

Mode = enum.Flag('Mode', 'r, w')  # Since 3.6, Flags compatible with &, |, ^, ~
====== Type checking and deduction
=== cpp
decltype(a->x) y;   // type of y is double (declared type)
decltype((a->x)) z = y; // type of z is const double& (lvalue expression)

// When return type depends on template parameters
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u)
{
}

// Type checking (statically at compile time)
std::is_same<T1, T2>::value // Or is_same_v<T> since C++14
std::remove_reference<int>::type // Or remove_reference_t<T>
=== java
=== python
type(o) is str
isinstance(o, str)
===============================================
====== Casting
=== cpp
// Cast
static_cast<>(x) // Standard conversion (ex: double to float)
reinterpret_cast<>(x) // Bits don’t change (ex: char* to int*)
const_cast<>(c)
dynamic_cast<>(); // For inheritance

// To overload cast
explicit operator bool () const; // explicit prevent bool a = obj
operator int* () const; // Note the absence of return value in the signature
operator MyType () const; // Custom cast
=== java
float newVar = (float)oldVar; // C like syntax
=== python
str(x)
int(x) // associated __int__(self) to overload
float(x)
bin(6) # Return string '0b110', x=int('0b110', base=2)
list(x)
===============================================
====== Binary/ranges
=== cpp
// The standard don't fix precise size but usually:
// Type       | Bits | Bytes  |    Max val
// char          8       1        127 / 255
// short (int)  16       2         32,000
// int/long     32       4   2,000,000,000 (billion)
// long long    64       8          10^19
// float        32       4         10^+/-38
// double       64       8        10^+/-300

// Fixed-size available:
uint8_t // u for unsigned
int64_t // 8, 16, 32 and 64 available

=== java
=== python
# No precision limit for int (a = 10**100+1 valid)

# For better precision on decimals
decimal.getcontext().prec = decimal.MAX_PREC
decimal.Decimals('3.142342423452')

# Fraction module to keep quotient/denominator

# complex(img, real) type
===============================================
====== Operators/Overload
=== cpp
// Associativity: Usually left to right: (((a+b)+c)+d) or ((a<<b)<<c)

// Binary ops:
// AND: &
// OR: |
// NOT: ~
// XOR: ^
// Shift right: >>  // Warning: strong bit is copied (negative stay negative)
// Shift left: <<  // Fill with 0s

// Overloading the operators
A operator+(const A& other); // Can be non member

// Others
int operator int()
void operator new
void operator new []
A* operator ->(); // Must return ptr, obj or ref
void operator++(0);
void operator[](int index); // Only one arg (contrary to Python), can be anything (ex: sting key)
void operator()(Args...);
bool operator >=(const T& other) const; // WARNING: Don't forget const when necessary (comparison operators)

A operator= (A&& ); // Move assignment operator
=== java
// No operator overloading in java
=== python
# As C++, most ops are left-associative
# ((a * b) // c) or ((a**b)**c)

**  # __pow__
/  # __truediv__ (diff between 2.6 and py 3)
//  # __floordiv__
@ # __matmul__ (since 3.5, no built-in implement it)
divmod(x, y) # return the pair (x // y, x % y)

+= # __iadd__  (i stand for in-place)

# right-side ops, ex: __rsub__ allows (4 - my_obj)
#   - only used if (4).__sub__(my_obj) don't exist
#   - and 4 and my_obj are from different types (what if children ?)

__neg__  # or __pos__ : Unary ops (ex: a = -x)
__invert__ # for ~ x ; __abs__ or __round__

def __add__(self, other):

def __lt__(self, other):  // lesser than (<) __le__ for <=

def __call__(self, *args, **kwargs):

def __str__(self):

def __getitem__(self, item):  # For x['a',...,3:5]
    # item can be a tuple of the passed arguments, ex: ('a', Ellipsis, slice(3,5,None))
    # Can check if args contains Ellipsis object (same as ...)
    # x:y are converted into `slice` objects (slice(start=, end=, step=))

# TODO: What does __index__() does ? return self for integer ?
===============================================
====== Functions/lambda
=== cpp
std::function<void(int)> f = fct; // Store a function
auto f = std::bind(fct, 42, std::placeholders::_1);  // Prefer lambda instead
=== java
=== python
f = functools.partial(fct, 42, arg2=43)
===============================================
====== ##Formatting/alternate representation
=== cpp
10u // Unsigned
10uLL // Unsigned long long
10'000.0 // double // ' since C++14
0.f // Float
0xFF00
0b1101'0100 // 0b since C++14

size_t length = 1'000'000 * nb_row;  // Warning: the computation is done as int. Risk of overflow !
=== java
=== python
1_000.0  # _ since python 3.6
================================================================================
========= Collections
===============================================
====== Iterators
=== cpp
// Concepts:
// ForwardIterator (just +)
// BidirectionalIterator (iter - 5 valid)
// RandomAccessIterator (cst access to any elems)


while(v.begin() != v.end()){} // Warning: != and not <
v.rbegin() // Reverse iterator (should be compared with .rend())
=== java
// implement Iterable, override:
// .iterator()
// boolean .hasNext()
// Item .next()
// .remove()
=== python
i = iter([1, 2, 3, 4])
x = next(i)  # Or i.__next__() for 3.x, i.next() for 2.6 : Return elem (not yield)
i.__length_hint__()  # ==3 : Nb of elem left, optional

# To create own iterator:
# Either overload __iter__(self) as a generator (yield)
# Either __iter__ return an object (potentially self) which overload __next__

# Iters have 2nd arg for sentinel value (exit if encounter), first arg should be callable function
for c in iter(my_fct, ''):  # Exit when my_fct return ''
    var.append(c)

# Generators
def f():
   for i in range(10):
      yield i
gen = f()  # Return instantaneously
next(gen)  # Execute the function up to the next yield
# Raise StopIteration when finished
===============================================
====== Vector
=== cpp
std::vector<T> v;
std::array<T, N> v; // Since C++11, in practice more trouble (ex:array of array), only use when perfs critical

=== java
=== python
my_list = []
===============================================
====== List/queues
=== cpp
std::list<T> l; // Double linked list (O(1) time remove any elem)
std::deque<T> l; // O(1) time for random access
std::forward_list<T> l; // C++11
=== java
Stack<Item> s;
= s.pop()
s.push(Item);

Queue<Item> q;
q.enqueue(Item);
= q.dequeue();

=== python
===============================================
====== HashTable
=== cpp
=== java
=== python
# ---- Sets: Warning: ----
#   set       VS       dictionary
{1, 2, 3}     VS  {1:’2’, 2:’2’, 4:’4’}
set()         VS  {}
a = set()
a |= {1, 2, 3}  # += Don’t exist, neither .extend()
a.add(2)  # Single elem only
a.remove(2)
a.pop() # Choose random elem
# Other ops &= (intersection), ^= (exclude comuns), -=
# set can be compared (<: incude, <=, .isdisjoint(other))

===============================================
====== Other
=== cpp
=== java
=== python
# Tuple:
(a,e,t)
(singleton,)  # Warning: ending comma ,

# namedtuple
Color = collections.namedtuple('Color', ['r', 'g', 'b'])
c = Color(255, 0, 124)
===============================================
====== Common collections methods
=== cpp
=== java
=== python
================================================================================
========= Other
===============================================
====== Example
=== cpp
=== java
=== python
